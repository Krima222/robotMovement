// библиотека для работы с портами ввода-вывода
#include <avr/io.h>
// библиотека тактовой частоты
#define F_CRU 16000000UL // 16 MHz
// библиотека для работы с прерываниями
#include <avr/interrupt.h>

volatile uint16_t adc_data = 0;

//обработчик прерывания при
ISR(ADC_vect)
{
adc_data = ADCW; // ADCL | (ADCH « 8)
}

int main ()
{
//ОТКЛЮЧАЕМ ПРЕРЫВАНИЕ
cli();

ADCSRA = (1 « ADEN) | (1 « ADSC) | (1 « ADATE);

//разрешаем прерывание от АЦП
ADCSRA |= 1 « ADIE;

//тактовую частоту мк делим на 128, частота ацп 125 кГц
ADCSRA |= (1 « ADPS1) | (1 « ADPS0) | (1 « ADPS2);

//ОПОРНОЕ НАПРЯЖЕНИЕ - НАПРЯЖЕНИЕ ПИТАНИЯ AVCC
ADMUX = (1 « REFS0) | (1 « MUX0); //левый датчи у 2 робота


//настроить ножки на выход на 2 и 3, регистр DDR (порт PE4)
DDRE |= (1 « PE4)| (1 « PE5);

//выбираем режим работы таймера Fast PWM (TOP = ICR3) (изначально все 0, на первом запуске),
//на регистре TCCR3A
//ВКЛЮЧАЕМ БИТ WGM31
TCCR3A = (1 « WGM31);
TCCR3B = (1 « WGM32)| (1 « WGM33);
//ВЫБИРАЕМ ШИМ(У НАС НЕИНВЕНТИРОВАННЫЙ РЕЖИМ РАБОТЫ НА B И C)РЕГИСТР МЫ УЖЕ ИСПОЛЬЗОВАЛИ,
//НЕЛЬЗЯ ПЕРЕЗАПИСЫВАТЬ ПОЭТОМУ ДЕЛАЕМ ЛОГИЧЕСКОЕ СЛОЖЕНИЕ

TCCR3A |= (1 « COM3B1) | (1 « COM3C1);
//НАСТРАИВАЕМ ПРЕДДЕЛИТЕЛЯ (PRESCALING)clk/1 НАС ИНТЕРЕСУЮТ БИТЫ CS30, КАКОЙ У НЕГО РЕГИСТР
TCCR3B |= 1 « CS30;
// ЗАПИСЫВАЕТ TOP VALUE, ТАЙМЕР СЧИТАЕТ ОТ 0 ДО TOP
ICR3 = 3199;
// ЗАПОЛНЕНИЕ ШИМ (duty cycle) (от 0 до top)
void moveForward(int a) {
OCR3B = a;
OCR3C = a;
}
moveForward(500);
//РАЗРЕШАЕМ ПРЕРЫВАНИЕ
sei();


while(true)
{
if (adc_data > 300) {
moveForward(0);
}
}
}
