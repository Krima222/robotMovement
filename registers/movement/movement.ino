int main ()
  {
  //ОТКЛЮЧАЕМ ПРЕРЫВАНИЕ
  cli();
  
  //настроить ножки на выход на 2 и 3, регистр DDR (порт pe4)
  DDRE |= (1 << PE4)| (1 << PE5);
  DDRL |= (1 << PL0);//49 пин(правое колесо) на выход
  DDRB |= (1 << PB2);//51 пин(левое колесо) на выход
  //выбираем режим работы таймера Fast PWM (TOP = ICR3) (изначально все 0, на первом запуске), на регистре TCCR3A
  //ВКЛЮЧАЕМ БИТ WGM31
  TCCR3A = (1 << WGM31);
  TCCR3B = (1 << WGM32)| (1 << WGM33);
  //ВЫБИРАЕМ ШИМ(У НАС НЕИНВЕНТИРОВАННЫЙ РЕЖИМ РАБОТЫ НА B И C)РЕГИСТР МЫ УЖЕ ИСПОЛЬЗОВАЛИ, НЕЛЬЗЯ ПЕРЕЗАПИСЫВАТЬ ПОЭТОМУ ДЕЛАЕМ ЛОГИЧЕСКОЕ СЛОЖЕНИЕ
  TCCR3A |= (1 << COM3B1) | (1 << COM3C1);
  //НАСТРАИВАЕМ ПРЕДДЕЛИТЕЛЬ (PRESCALING)clk/1 НАС ИНТЕРЕСУЮТ БИТЫ CS30
  TCCR3B |= 1 << CS30;
  // ЗАПИСЫВАЕТ TOP VALUE, ТАЙМЕР СЧИТАЕТ ОТ 0 ДО TOP
  ICR3 = 3199;

  //РАЗРЕШАЕМ ПРЕРЫВАНИЕ
  sei();
  
  rightEngineDriver(500);
  leftEngineDriver(500);
}

void rightEngineDriver(int a) {
  if (a >= 0) {
    OCR3B = a;  //ЗАПОЛНЕНИЕ ШИМ (duty cycle) (от 0 до top)
    PORTL &= ~(1 << PL0); //Для того, чтобы ехал вперёд (49 LOW)
  } else {
    OCR3B = 2500 + a;
    PORTL |= (1 << PL0); //Для того, чтобы ехал назад (49 HIGH)
  }
}

void leftEngineDriver(int a) {
  if (a >= 0) {
    OCR3C = a;  //ЗАПОЛНЕНИЕ ШИМ (duty cycle) (от 0 до top)
    PORTB &= ~(1 << PB2); //Для того, чтобы ехал вперёд (51 LOW)
  } else {
    OCR3C = 2500 + a;
    PORTB |= (1 << PB2); //Для того, чтобы ехал назад (51 HIGH)
  }
}
